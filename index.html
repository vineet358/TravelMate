<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Haldwani Pathfinder - Enhanced</title>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }
        
        #sidebar {
            width: 350px;
            height: 100%;
            background-color: #f5f5f5;
            padding: 15px;
            box-sizing: border-box;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        
        #map {
            flex: 1;
            height: 100%;
        }
        
        h1, h2, h3, h4 {
            color: #333;
            margin-top: 0;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }
        
        select, button {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        
        button {
            background-color: #4285F4;
            color: white;
            border: none;
            cursor: pointer;
            margin-top: 5px;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #3367d6;
        }
        
        #resetBtn {
            background-color: #f44336;
        }
        
        #resetBtn:hover {
            background-color: #d32f2f;
        }
        
        #showAllLocationsBtn {
            background-color: #4CAF50;
        }
        
        #showAllLocationsBtn:hover {
            background-color: #388E3C;
        }
        
        .route-detail {
            background-color: white;
            border-radius: 8px;
            padding: 12px;
            margin-top: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .route-detail h3 {
            margin-top: 0;
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
        }
        
        .route-detail ol {
            padding-left: 20px;
        }
        
        .route-detail li {
            margin-bottom: 8px;
        }
        
        .poi-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .poi-item {
            background-color: white;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .poi-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        
        .poi-item.selected {
            border-left: 4px solid #4285F4;
        }
        
        .poi-name {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .poi-address {
            font-size: 0.9em;
            color: #555;
            margin-bottom: 5px;
        }
        
        .poi-rating {
            color: #FBC02D;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .poi-directions-btn {
            padding: 5px 10px;
            font-size: 0.8em;
            margin-top: 5px;
        }
        
        .filter-item {
            margin-bottom: 8px;
        }
        
        .filter-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .filter-actions button {
            flex: 1;
        }
        
        #clearFiltersBtn {
            background-color: #9e9e9e;
        }
        
        #clearFiltersBtn:hover {
            background-color: #757575;
        }
        
        .poi-loading {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            color: #555;
        }
        
        .poi-type-group {
            margin-bottom: 15px;
        }
        
        .poi-type-group h4 {
            margin-bottom: 8px;
        }
        
        .route-mode-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .route-mode-option {
            flex: 1;
            text-align: center;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .route-mode-option.active {
            background-color: #4285F4;
            color: white;
            border-color: #4285F4;
        }
        
        .leaflet-popup-content {
            min-width: 200px;
        }
        
        .info-window button, .poi-info-window button, .location-info-window button {
            margin-top: 10px;
            padding: 5px 10px;
            background-color: #4285F4;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .loading-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255,255,255,0.8);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            display: none;
        }
        
        .loading-spinner {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #4285F4;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .attribution {
            font-size: 0.8em;
            color: #666;
            margin-top: 10px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="sidebar">
        <h1>Haldwani Pathfinder</h1>
        
        <div class="form-group">
            <label for="sourceLocation">Source Location:</label>
            <select id="sourceLocation">
                <option value="">Select Source Location</option>
                <!-- Options will be populated dynamically -->
            </select>
        </div>
        
        <div class="form-group">
            <label for="destinationLocation">Destination Location:</label>
            <select id="destinationLocation">
                <option value="">Select Destination Location</option>
                <!-- Options will be populated dynamically -->
            </select>
        </div>
        
        <div class="route-mode-selector">
            <div class="route-mode-option active" data-mode="driving">Driving</div>
            <div class="route-mode-option" data-mode="walking">Walking</div>
            <div class="route-mode-option" data-mode="cycling">Cycling</div>
        </div>
        
        <div class="form-group">
            <button id="findPathBtn">Find Path</button>
            <button id="resetBtn">Reset</button>
            <button id="showAllLocationsBtn">Show All Locations</button>
        </div>
        
        <div id="routeInfo">
            <!-- Route information will be displayed here -->
        </div>
        
        <div id="poiFilters">
            <!-- POI filters will be populated dynamically -->
        </div>
        
        <div id="poiContainer">
            <!-- POIs will be displayed here -->
        </div>
        
        <div class="attribution">
            Â© OpenStreetMap contributors | Routing: OpenRouteService | POI data: Overpass API
        </div>
    </div>
    
    <div id="map"></div>
    
    <div class="loading-indicator" id="loadingIndicator">
        <div class="loading-spinner"></div>
        <div>Processing your request...</div>
    </div>
    
    <!-- Leaflet JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    
    <!-- Mock data for Haldwani locations -->
    <script>
        // Mock data representing locations in Haldwani
        const haldwaniData = {
            nodes: [
                { id: "n1", name: "Haldwani Railway Station", lat: 29.2238, lng: 79.5133 },
                { id: "n2", name: "Sushila Tiwari Hospital", lat: 29.2134, lng: 79.5160 },
                { id: "n3", name: "Nainital Bank Head Office", lat: 29.2207, lng: 79.5166 },
                { id: "n4", name: "KMC Sports Ground", lat: 29.2134, lng: 79.5280 },
                { id: "n5", name: "Nainital Road Bus Stand", lat: 29.2187, lng: 79.5057 },
                { id: "n6", name: "Haldwani Degree College", lat: 29.2260, lng: 79.5295 },
                { id: "n7", name: "Gaulapar Bus Stand", lat: 29.2296, lng: 79.5058 },
                { id: "n8", name: "Chitrashila Auditorium", lat: 29.2173, lng: 79.5123 },
                { id: "n9", name: "Nainital Road Market", lat: 29.2198, lng: 79.5082 },
                { id: "n10", name: "Bhotia Parao Market", lat: 29.2173, lng: 79.5228 },
                { id: "n11", name: "Govt. Medical College", lat: 29.2041, lng: 79.5120 },
                { id: "n12", name: "ISBT Haldwani", lat: 29.2126, lng: 79.4998 },
                { id: "n13", name: "Pacific Mall", lat: 29.2320, lng: 79.4976 },
                { id: "n14", name: "Kathgodam Railway Station", lat: 29.2657, lng: 79.5352 },
                { id: "n15", name: "Gomti River Bridge", lat: 29.2350, lng: 79.5196 },
                { id: "n16", name: "Ranibagh Industrial Area", lat: 29.2383, lng: 79.5484 },
                { id: "n17", name: "Zoo Road", lat: 29.2063, lng: 79.5309 },
                { id: "n18", name: "Sanjay Nagar", lat: 29.2242, lng: 79.5361 },
                { id: "n19", name: "Mukhani Market", lat: 29.2316, lng: 79.5224 },
                { id: "n20", name: "Mangal Parao", lat: 29.2025, lng: 79.5229 }
            ],
            edges: [
                { source: "n1", target: "n3", distance: 0.5 },
                { source: "n1", target: "n5", distance: 0.8 },
                { source: "n1", target: "n7", distance: 0.9 },
                { source: "n1", target: "n8", distance: 0.6 },
                { source: "n1", target: "n9", distance: 0.7 },
                { source: "n2", target: "n4", distance: 1.2 },
                { source: "n2", target: "n11", distance: 1.0 },
                { source: "n2", target: "n17", distance: 1.8 },
                { source: "n2", target: "n20", distance: 1.1 },
                { source: "n3", target: "n8", distance: 0.5 },
                { source: "n3", target: "n9", distance: 0.7 },
                { source: "n4", target: "n10", distance: 0.9 },
                { source: "n4", target: "n17", distance: 0.8 },
                { source: "n4", target: "n20", distance: 1.0 },
                { source: "n5", target: "n9", distance: 0.4 },
                { source: "n5", target: "n12", distance: 0.8 },
                { source: "n6", target: "n10", distance: 1.0 },
                { source: "n6", target: "n18", distance: 0.7 },
                { source: "n7", target: "n9", distance: 1.2 },
                { source: "n7", target: "n13", distance: 1.0 },
                { source: "n7", target: "n15", distance: 1.5 },
                { source: "n8", target: "n9", distance: 0.4 },
                { source: "n8", target: "n10", distance: 1.0 },
                { source: "n10", target: "n15", distance: 1.6 },
                { source: "n10", target: "n19", distance: 1.5 },
                { source: "n11", target: "n12", distance: 1.2 },
                { source: "n11", target: "n20", distance: 1.0 },
                { source: "n12", target: "n13", distance: 2.0 },
                { source: "n13", target: "n15", distance: 2.2 },
                { source: "n14", target: "n15", distance: 3.0 },
                { source: "n14", target: "n16", distance: 1.5 },
                { source: "n15", target: "n16", distance: 2.8 },
                { source: "n15", target: "n19", distance: 0.6 },
                { source: "n16", target: "n18", distance: 2.0 },
                { source: "n17", target: "n20", distance: 0.9 },
                { source: "n18", target: "n19", distance: 1.4 }
            ]
        };
    </script>
    
    <!-- Haldwani Pathfinder Main Script -->
    <script>
        // Constants for map initialization
        const HALDWANI_CENTER = [29.2183, 79.5130]; // Default center coordinates for Haldwani
        const HALDWANI_ZOOM = 14; // Default zoom level
        
        // API Keys for services
        const OPENROUTE_API_KEY = "5b3ce3597851110001cf624810c776dba3264d8f9bc9f5bb8c9fc2c5"; // Replace with your actual API key
        
        // Global variables
        let map;
        let routeLayer;
        let markers = [];
        let sourceMarker = null;
        let destinationMarker = null;
        let graph; // For storing the graph representation of the road network
        let activePOITypes = []; // For tracking active POI filters
        let currentRouteMode = "driving"; // Default route mode
        
        // Marker icons
        const markerIcons = {
            source: L.icon({
                iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34],
                shadowSize: [41, 41]
            }),
            destination: L.icon({
                iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34],
                shadowSize: [41, 41]
            }),
            poi: L.icon({
                iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',
                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34],
                shadowSize: [41, 41]
            })
        };
        
        // POI type icons
        const poiTypeIcons = {
            restaurant: L.icon({
                iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',
                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34],
                shadowSize: [41, 41]
            }),
            cafe: L.icon({
                iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-yellow.png',
                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34],
                shadowSize: [41, 41]
            }),
            hotel: L.icon({
                iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-orange.png',
                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34],
                shadowSize: [41, 41]
            }),
            atm: L.icon({
                iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-violet.png',
                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34],
                shadowSize: [41, 41]
            }),
            hospital: L.icon({
                iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34],
                shadowSize: [41, 41]
            }),
            school: L.icon({
                iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34],
                shadowSize: [41, 41]
            }),
            shop: L.icon({
                iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-purple.png',
                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34],
                shadowSize: [41, 41]
            }),
            place_of_worship: L.icon({
                iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-black.png',
                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34],
                shadowSize: [41, 41]
            }),
            fuel: L.icon({
                iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-grey.png',
                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34],
                shadowSize: [41, 41]
            })
        };

        // Initialize the map and core services when the window loads
        window.onload = function() {
            initMap();
            createGraph();
            populateLocationDropdowns();
            
            // Set up event listeners
            document.getElementById('findPathBtn').addEventListener('click', handleFindPathClick);
            document.getElementById('resetBtn').addEventListener('click', resetMap);
            document.getElementById('showAllLocationsBtn').addEventListener('click', showAllLocations);
            
            // Location selectors change handlers
            document.getElementById('sourceLocation').addEventListener('change', function() {
                updateSelectedLocation('source', this.value);
            });
            
            document.getElementById('destinationLocation').addEventListener('change', function() {
                updateSelectedLocation('destination', this.value);
            });
            
            // Setup route mode selector
            const routeModeOptions = document.querySelectorAll('.route-mode-option');
            routeModeOptions.forEach(option => {
                option.addEventListener('click', function() {
                    // Remove active class from all options
                    routeModeOptions.forEach(opt => opt.classList.remove('active'));
                    
                    // Add active class to clicked option
                    this.classList.add('active');
                    
                    // Update current route mode
                    currentRouteMode = this.dataset.mode;
                    
                    // Recalculate route if both source and destination are set
                    if (sourceMarker && destinationMarker) {
                        handleFindPathClick();
                    }
                });
            });
            
            // Setup POI category filters
            setupPOIFilters();
        };

        // Initialize the Leaflet Map centered on Haldwani
        function initMap() {
            // Create map instance
            map = L.map('map').setView(HALDWANI_CENTER, HALDWANI_ZOOM);
            
            // Add OpenStreetMap tile layer
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                maxZoom: 19
            }).addTo(map);
            
            // Create a layer group for routes
            routeLayer = L.layerGroup().addTo(map);
            
            // Add click event to the map for custom location selection
            map.on('click', function(event) {
                // If no source is selected, set it as source
                if (!sourceMarker) {
                    placeMarker(event.latlng, 'source');
                } 
                // If source is selected but no destination, set it as destination
                else if (!destinationMarker) {
                    placeMarker(event.latlng, 'destination');
                    handleFindPathClick();
                } 
                // If both are selected, reset and start over with this as source
                else {
                    resetMap();
                    placeMarker(event.latlng, 'source');
                }
            });
        }

        // Create a graph representation of the road network from haldwaniData
        function createGraph() {
            graph = {};
            
            // Initialize nodes
            haldwaniData.nodes.forEach(node => {
                graph[node.id] = {
                    name: node.name,
                    lat: node.lat,
                    lng: node.lng,
                    neighbors: []
                };
            });
            
            // Add edges (connections between nodes)
            haldwaniData.edges.forEach(edge => {
                // Add bidirectional edges
                graph[edge.source].neighbors.push({
                    id: edge.target,
                    distance: edge.distance
                });
                
                graph[edge.target].neighbors.push({
                    id: edge.source,
                    distance: edge.distance
                });
            });
        }

        // Populate dropdown menus with location data
        function populateLocationDropdowns() {
            const sourceDropdown = document.getElementById('sourceLocation');
            const destinationDropdown = document.getElementById('destinationLocation');
            
            // Clear existing options
            sourceDropdown.innerHTML = '<option value="">Select Source Location</option>';
            destinationDropdown.innerHTML = '<option value="">Select Destination Location</option>';
            
            // Add locations from the data file
            haldwaniData.nodes.forEach(location => {
                // Create options for source dropdown
                const sourceOption = document.createElement('option');
                sourceOption.value = location.id;
                sourceOption.textContent = location.name;
                sourceDropdown.appendChild(sourceOption);
                
                // Create options for destination dropdown
                const destOption = document.createElement('option');
                destOption.value = location.id;
                destOption.textContent = location.name;
                destinationDropdown.appendChild(destOption);
            });
        }

        // Handle find path button click
        function handleFindPathClick() {
            // Make sure we have both source and destination
            if (!sourceMarker || !destinationMarker) {
                alert('Please select both source and destination locations');
                return;
            }
            
            // Show loading indicator
            document.getElementById('loadingIndicator').style.display = 'block';
            
            // Get source and destination positions
            const sourcePos = sourceMarker.getLatLng();
            const destPos = destinationMarker.getLatLng();
            
            // Calculate route using OpenRouteService API
            calculateRouteWithAPI(sourcePos, destPos, currentRouteMode);
        }

        // Update the map when a location is selected from dropdowns
        function updateSelectedLocation(type, locationId) {
            if (!locationId) return;
            
            // Find the selected location in our data
            const selectedLocation = haldwaniData.nodes.find(loc => loc.id === locationId);
            
            if (selectedLocation) {
                const position = { 
                    lat: selectedLocation.lat, 
                    lng: selectedLocation.lng 
                };
                
                // Place marker based on type
                placeMarker(position, type);
                
                // Center map on the selected location
                map.setView([position.lat, position.lng], 15);
                
                // If both source and destination are selected, calculate route
                if (sourceMarker && destinationMarker) {
                    handleFindPathClick();
                }
            }
        }

        // Place a marker on the map (source or destination)
        function placeMarker(position, type) {
            // Remove previous marker of the same type if it exists
            if (type === 'source' && sourceMarker) {
                map.removeLayer(sourceMarker);
                sourceMarker = null;
            } else if (type === 'destination' && destinationMarker) {
                map.removeLayer(destinationMarker);
                destinationMarker = null;
            }
            
            // Create the marker with appropriate icon
            const marker = L.marker([position.lat, position.lng], {
                icon: markerIcons[type],
                draggable: true // Make markers draggable
            }).addTo(map);
            const popupContent = document.createElement('div');
            popupContent.className = 'info-window';
            
            // Add content based on type
            if (type === 'source') {
                popupContent.innerHTML = `
                    <h3>Source Location</h3>
                    <p>Latitude: ${position.lat.toFixed(6)}</p>
                    <p>Longitude: ${position.lng.toFixed(6)}</p>
                `;
                
                // Find nearest known location
                const nearestNode = findNearestNode(position);
                if (nearestNode) {
                    popupContent.innerHTML += `
                        <p>Nearest location: ${nearestNode.name}</p>
                        <button class="snap-to-location" data-id="${nearestNode.id}" data-type="source">Snap to ${nearestNode.name}</button>
                    `;
                }
            } else {
                popupContent.innerHTML = `
                    <h3>Destination Location</h3>
                    <p>Latitude: ${position.lat.toFixed(6)}</p>
                    <p>Longitude: ${position.lng.toFixed(6)}</p>
                `;
                
                // Find nearest known location
                const nearestNode = findNearestNode(position);
                if (nearestNode) {
                    popupContent.innerHTML += `
                        <p>Nearest location: ${nearestNode.name}</p>
                        <button class="snap-to-location" data-id="${nearestNode.id}" data-type="destination">Snap to ${nearestNode.name}</button>
                    `;
                }
            }
            
            // Bind the popup to the marker
            marker.bindPopup(popupContent);
            
            // Add event listener for the snap button (will be added when popup is opened)
            marker.on('popupopen', function() {
                const snapButton = document.querySelector('.snap-to-location');
                if (snapButton) {
                    snapButton.addEventListener('click', function() {
                        const nodeId = this.dataset.id;
                        const markerType = this.dataset.type;
                        const node = haldwaniData.nodes.find(n => n.id === nodeId);
                        
                        // Update dropdown selection
                        document.getElementById(`${markerType}Location`).value = nodeId;
                        
                        // Update marker position
                        updateSelectedLocation(markerType, nodeId);
                        
                        // Close popup
                        marker.closePopup();
                    });
                }
            });
            
            // Handle marker drag end event
            marker.on('dragend', function() {
                // Recalculate route if both markers are present
                if (sourceMarker && destinationMarker) {
                    handleFindPathClick();
                }
            });
            
            // Store the marker in appropriate variable
            if (type === 'source') {
                sourceMarker = marker;
                document.getElementById('sourceLocation').value = ''; // Clear dropdown
            } else {
                destinationMarker = marker;
                document.getElementById('destinationLocation').value = ''; // Clear dropdown
            }
        }

        // Find the nearest node in our data to the given position
        function findNearestNode(position) {
            let nearestNode = null;
            let minDistance = Infinity;
            
            haldwaniData.nodes.forEach(node => {
                const distance = getDistance(
                    { lat: position.lat, lng: position.lng },
                    { lat: node.lat, lng: node.lng }
                );
                
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestNode = node;
                }
            });
            
            return nearestNode;
        }

        // Calculate distance between two points in km using the Haversine formula
        function getDistance(point1, point2) {
            const R = 6371; // Earth's radius in km
            const dLat = (point2.lat - point1.lat) * Math.PI / 180;
            const dLon = (point2.lng - point1.lng) * Math.PI / 180;
            
            const a = 
                Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(point1.lat * Math.PI / 180) * Math.cos(point2.lat * Math.PI / 180) * 
                Math.sin(dLon/2) * Math.sin(dLon/2);
            
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        function calculateRouteWithAPI(sourcePos, destPos, mode) {
    // API endpoint
    const apiUrl = 'https://api.openrouteservice.org/v2/directions/';
    
    // Map route modes to ORS profiles
    const profileMap = {
        'driving': 'driving-car',
        'walking': 'foot-walking',
        'cycling': 'cycling-regular'
    };
    
    const profile = profileMap[mode] || 'driving-car';

    // â Your actual OpenRouteService API key
    const OPENROUTE_API_KEY = '5b3ce3597851110001cf62483af92f8f1bc04a3fae4b61c61b1a43e1';

    // Construct the original API URL
    const originalUrl = `${apiUrl}${profile}?api_key=${OPENROUTE_API_KEY}&start=${sourcePos.lng},${sourcePos.lat}&end=${destPos.lng},${destPos.lat}`;
    
    // Use a CORS proxy (for development only)
    const corsProxyUrl = 'http://localhost:8080/';

    const requestUrl = corsProxyUrl + originalUrl;
    
    console.log(`Requesting route from OpenRouteService: ${profile} mode`);

    // Make the API request
    fetch(requestUrl)
        .then(response => {
            if (!response.ok) {
                console.error(`API responded with status: ${response.status}`);
                return response.text().then(text => {
                    console.error(`API error response: ${text}`);
                    throw new Error(`HTTP error! Status: ${response.status}`);
                });
            }
            return response.json();
        })
        .then(data => {
            console.log('Successfully received route data from API');
            // Display the route on the map
            displayRouteFromAPI(data);
        })
        .catch(error => {
            console.error('Error fetching route:', error);
            alert(`Failed to get route: ${error.message}. Falling back to local calculation.`);
            calculateRouteWithDijkstra(sourcePos, destPos);
        })
        .finally(() => {
            // Hide loading indicator if any
            const loader = document.getElementById('loadingIndicator');
            if (loader) loader.style.display = 'none';
        });
}

// Display route from API response
function displayRouteFromAPI(routeData) {
    // Clear previous route
    routeLayer.clearLayers();
    
    try {
        console.log('Route data:', routeData);
        
        // Validate the API response structure
        if (!routeData.features || !routeData.features[0] || !routeData.features[0].geometry) {
            throw new Error('Invalid route data structure received from API');
        }
        
        // Extract route geometry from the response
        const geometry = routeData.features[0].geometry.coordinates;
        
        console.log(`Route has ${geometry.length} coordinate points`);
        
        // Convert to Leaflet format (swap lat and lng)
        const routePoints = geometry.map(coord => [coord[1], coord[0]]);
        
        // Create polyline with route
        const routePolyline = L.polyline(routePoints, {
            color: '#4285F4',
            weight: 6,
            opacity: 0.7
        }).addTo(routeLayer);
        
        // Zoom map to fit the route
        map.fitBounds(routePolyline.getBounds(), {
            padding: [50, 50]
        });
        
        // Extract route summary
        const summary = routeData.features[0].properties.summary;
        
        // Display route information
        displayRouteInfo({
            distance: summary.distance / 1000, // Convert to km
            duration: summary.duration / 60,   // Convert to minutes
            points: routePoints
        });
        
        // Fetch POIs along the route
        fetchPOIsAlongRoute(routePoints);
        
    } catch (error) {
        console.error('Error processing route data:', error);
        alert('Error processing route data. Please try again.');
    }
}

       

        // Calculate route with Dijkstra's algorithm (fallback option)
        function calculateRouteWithDijkstra(sourcePos, destPos) {
            // Find the nearest nodes to the selected points
            const sourceNode = findNearestNode(sourcePos);
            const destNode = findNearestNode(destPos);
            
            if (!sourceNode || !destNode) {
                alert('Could not find suitable road network near selected points.');
                return;
            }
            
            // Run Dijkstra's algorithm
            const { distance, path } = dijkstraShortestPath(sourceNode.id, destNode.id);
            
            if (!path || path.length === 0) {
                alert('Could not find a path between the selected locations.');
                return;
            }
            
            // Convert path to route points
            const routePoints = path.map(nodeId => {
                const node = graph[nodeId];
                return [node.lat, node.lng];
            });
            
            // Display the route
            displayRoute({
                distance: distance,
                duration: distance * 3, // Rough estimate: 20 km/h average speed
                points: routePoints
            });
        }

        // Dijkstra's algorithm for finding shortest path
        function dijkstraShortestPath(startNodeId, endNodeId) {
            // Initialize data structures
            const distances = {};
            const previous = {};
            const unvisited = new Set();
            
            // Initialize all distances as Infinity and add all nodes to unvisited set
            Object.keys(graph).forEach(nodeId => {
                distances[nodeId] = Infinity;
                previous[nodeId] = null;
                unvisited.add(nodeId);
            });
            
            // Distance from start node to itself is 0
            distances[startNodeId] = 0;
            
            // Main algorithm loop
            while (unvisited.size > 0) {
                // Find the unvisited node with the smallest distance
                let currentNodeId = null;
                let smallestDistance = Infinity;
                
                for (const nodeId of unvisited) {
                    if (distances[nodeId] < smallestDistance) {
                        smallestDistance = distances[nodeId];
                        currentNodeId = nodeId;
                    }
                }
                
                // If smallest distance is Infinity, there's no path to destination
                if (smallestDistance === Infinity) {
                    break;
                }
                
                // If we've reached the end node, we're done
                if (currentNodeId === endNodeId) {
                    break;
                }
                
                // Remove current node from unvisited set
                unvisited.delete(currentNodeId);
                
                // Check all neighbors of current node
                const currentNode = graph[currentNodeId];
                
                for (const neighbor of currentNode.neighbors) {
                    // Only consider unvisited neighbors
                    if (unvisited.has(neighbor.id)) {
                        // Calculate tentative distance
                        const tentativeDistance = distances[currentNodeId] + neighbor.distance;
                        
                        // Update if this path is shorter
                        if (tentativeDistance < distances[neighbor.id]) {
                            distances[neighbor.id] = tentativeDistance;
                            previous[neighbor.id] = currentNodeId;
                        }
                    }
                }
            }
            
            // Reconstruct the path
            const path = [];
            let current = endNodeId;
            
            // If end node wasn't reached, return empty path
            if (previous[endNodeId] === null && endNodeId !== startNodeId) {
                return { distance: Infinity, path: [] };
            }
            
            // Build the path backwards
            while (current !== null) {
                path.unshift(current);
                current = previous[current];
            }
            
            return { distance: distances[endNodeId], path };
        }

        // Display route on the map
        function displayRoute(routeData) {
            // Clear previous route
            routeLayer.clearLayers();
            
            // Create polyline from route points
            const routePolyline = L.polyline(routeData.points, {
                color: '#4285F4',
                weight: 6,
                opacity: 0.7
            }).addTo(routeLayer);
            
            // Zoom map to fit the route
            map.fitBounds(routePolyline.getBounds(), {
                padding: [50, 50]
            });
            
            // Display route information
            displayRouteInfo(routeData);
            
            // Fetch POIs along the route
            fetchPOIsAlongRoute(routeData.points);
        }

        // Display route information in the sidebar
        function displayRouteInfo(routeData) {
            const routeInfoDiv = document.getElementById('routeInfo');
            
            // Format distance and duration
            const distance = routeData.distance.toFixed(2);
            
            // Get hours and minutes from duration (in minutes)
            const hours = Math.floor(routeData.duration / 60);
            const minutes = Math.round(routeData.duration % 60);
            let durationStr = '';
            
            if (hours > 0) {
                durationStr += `${hours} hour${hours > 1 ? 's' : ''} `;
            }
            
            if (minutes > 0 || hours === 0) {
                durationStr += `${minutes} minute${minutes !== 1 ? 's' : ''}`;
            }
            
            // Get travel mode
            const modeStr = currentRouteMode.charAt(0).toUpperCase() + currentRouteMode.slice(1);
            
            // Create HTML for route info
            routeInfoDiv.innerHTML = `
                <div class="route-detail">
                    <h3>Route Information</h3>
                    <p><strong>Distance:</strong> ${distance} km</p>
                    <p><strong>Estimated Duration:</strong> ${durationStr}</p>
                    <p><strong>Travel Mode:</strong> ${modeStr}</p>
                </div>
            `;
        }

        // Setup POI (Points of Interest) filters
        function setupPOIFilters() {
            const poiFiltersDiv = document.getElementById('poiFilters');
            
            // Define POI categories
            const poiCategories = [
                { type: 'restaurant', name: 'Restaurants' },
                { type: 'cafe', name: 'Cafes' },
                { type: 'hotel', name: 'Hotels' },
                { type: 'atm', name: 'ATMs' },
                { type: 'hospital', name: 'Hospitals' },
                { type: 'school', name: 'Schools' },
                { type: 'shop', name: 'Shops' },
                { type: 'place_of_worship', name: 'Places of Worship' },
                { type: 'fuel', name: 'Fuel Stations' }
            ];
            
            // Create filter HTML
            poiFiltersDiv.innerHTML = `
                <h3>Nearby Points of Interest</h3>
                <div class="poi-type-group">
                    ${poiCategories.map(category => `
                        <div class="filter-item">
                            <input type="checkbox" id="poi-${category.type}" data-poi-type="${category.type}">
                            <label for="poi-${category.type}">${category.name}</label>
                        </div>
                    `).join('')}
                </div>
                <div class="filter-actions">
                    <button id="applyFiltersBtn">Apply Filters</button>
                    <button id="clearFiltersBtn">Clear All</button>
                </div>
            `;
            
            // Add event listeners for filter buttons
            document.getElementById('applyFiltersBtn').addEventListener('click', applyPOIFilters);
            document.getElementById('clearFiltersBtn').addEventListener('click', clearPOIFilters);
        }

        // Apply POI filters
        function applyPOIFilters() {
            // Get all checked POI types
            const checkedPOIs = document.querySelectorAll('input[data-poi-type]:checked');
            activePOITypes = Array.from(checkedPOIs).map(input => input.dataset.poiType);
            
            // Re-fetch POIs if we have a route
            if (routeLayer.getLayers().length > 0) {
                const routeLayer = routeLayer.getLayers()[0];
                if (routeLayer) {
                    const routePoints = routeLayer.getLatLngs();
                    fetchPOIsAlongRoute(routePoints);
                }
            }
        }

        // Clear all POI filters
        function clearPOIFilters() {
            // Uncheck all POI type checkboxes
            document.querySelectorAll('input[data-poi-type]').forEach(input => {
                input.checked = false;
            });
            
            // Clear active POI types
            activePOITypes = [];
            
            // Clear POI display
            document.getElementById('poiContainer').innerHTML = '';
            
            // Remove POI markers from map
            markers.forEach(marker => {
                if (marker !== sourceMarker && marker !== destinationMarker) {
                    map.removeLayer(marker);
                }
            });
            
            // Keep only source and destination markers
            markers = markers.filter(marker => marker === sourceMarker || marker === destinationMarker);
        }

        // Fetch POIs along the route
        function fetchPOIsAlongRoute(routePoints) {
            // Clear previous POIs
            document.getElementById('poiContainer').innerHTML = '<div class="poi-loading">Loading nearby points of interest...</div>';
            
            // Remove previous POI markers
            markers.forEach(marker => {
                if (marker !== sourceMarker && marker !== destinationMarker) {
                    map.removeLayer(marker);
                }
            });
            
            // Keep only source and destination markers
            markers = markers.filter(marker => marker === sourceMarker || marker === destinationMarker);
            
            // Define POI types to search for
            const poiTypesToSearch = activePOITypes.length > 0 ? activePOITypes : ['restaurant', 'cafe', 'hotel'];
            
            // Create a buffer around the route (in degrees)
            const buffer = 0.01; // Roughly 1km
            
            // Find min and max coordinates to define the search area
            let minLat = 90, maxLat = -90, minLng = 180, maxLng = -180;
            
            routePoints.forEach(point => {
                minLat = Math.min(minLat, point[0]);
                maxLat = Math.max(maxLat, point[0]);
                minLng = Math.min(minLng, point[1]);
                maxLng = Math.max(maxLng, point[1]);
            });
            
            // Add buffer
            minLat -= buffer;
            maxLat += buffer;
            minLng -= buffer;
            maxLng += buffer;
            
            // For actual implementation, we would use Overpass API to fetch POIs
            // Since we can't make actual API calls in this example, we'll simulate POI data
            
            setTimeout(() => {
                // Generate synthetic POIs along the route
                const pois = generateSyntheticPOIs(routePoints, poiTypesToSearch);
                displayPOIs(pois);
            }, 1000);
        }

        // Generate synthetic POIs for demonstration
        function generateSyntheticPOIs(routePoints, poiTypes) {
            const pois = [];
            const numPOIs = Math.floor(Math.random() * 10) + 5; // Generate 5-15 POIs
            
            // POI name templates based on type
            const poiNameTemplates = {
                restaurant: ['Tasty', 'Spicy', 'Royal', 'Delicious', 'Golden'],
                cafe: ['Coffee', 'Chai', 'Tea', 'Mountain', 'Cozy'],
                hotel: ['Comfort', 'Luxury', 'Grand', 'Royal', 'Paradise'],
                atm: ['State Bank', 'ICICI', 'HDFC', 'PNB', 'Axis'],
                hospital: ['City', 'General', 'Memorial', 'Care', 'Medical'],
                school: ['Public', 'International', 'Modern', 'St. Mary', 'Central'],
                shop: ['Mega', 'Super', 'City', 'Grand', 'Discount'],
                place_of_worship: ['Temple', 'Church', 'Mosque', 'Gurudwara', 'Shrine'],
                fuel: ['HP', 'Indian Oil', 'Bharat', 'Reliance', 'Essar']
            };
            
            // POI suffix templates based on type
            const poiSuffixTemplates = {
                restaurant: ['Restaurant', 'Dhaba', 'Food Corner', 'Kitchen', 'Eatery'],
                cafe: ['Cafe', 'Coffee House', 'Tea House', 'Bistro', 'Lounge'],
                hotel: ['Hotel', 'Inn', 'Resort', 'Lodge', 'Homestay'],
                atm: ['ATM', 'Bank ATM', 'Cash Point', 'Money Center', 'Banking Point'],
                hospital: ['Hospital', 'Clinic', 'Medical Center', 'Healthcare', 'Nursing Home'],
                school: ['School', 'Academy', 'Institute', 'College', 'Education Center'],
                shop: ['Store', 'Mart', 'Market', 'Shop', 'Emporium'],
                place_of_worship: ['Temple', 'Church', 'Mosque', 'Gurudwara', 'Shrine'],
                fuel: ['Petrol Pump', 'Gas Station', 'Fuel Station', 'Petrol Station', 'Filling Station']
            };
            
            // Generate POIs
            for (let i = 0; i < numPOIs; i++) {
                // Pick a random POI type from the list
                const poiType = poiTypes[Math.floor(Math.random() * poiTypes.length)];
                
                // Pick a random point along the route
                const routePoint = routePoints[Math.floor(Math.random() * routePoints.length)];
                
                // Add some random offset
                const lat = routePoint[0] + (Math.random() - 0.5) * 0.01;
                const lng = routePoint[1] + (Math.random() - 0.5) * 0.01;
                
                // Generate a random name
                const prefix = poiNameTemplates[poiType][Math.floor(Math.random() * poiNameTemplates[poiType].length)];
                const suffix = poiSuffixTemplates[poiType][Math.floor(Math.random() * poiSuffixTemplates[poiType].length)];
                
                // Create POI object
                pois.push({
                    id: `poi-${i}`,
                    name: `${prefix} ${suffix}`,
                    type: poiType,
                    lat: lat,
                    lng: lng,
                    address: `${Math.floor(Math.random() * 100) + 1} ${['Main Road', 'Mall Road', 'Nainital Road', 'Railway Road', 'MG Road'][Math.floor(Math.random() * 5)]}, Haldwani`,
                    rating: (Math.random() * 2 + 3).toFixed(1) // Random rating between 3.0 and 5.0
                });
            }
            
            return pois;
        }

        // Display POIs on the map and in the sidebar
        function displayPOIs(pois) {
            const poiContainer = document.getElementById('poiContainer');
            
            // Clear previous content
            poiContainer.innerHTML = '';
            
            // If no POIs found
            if (pois.length === 0) {
                poiContainer.innerHTML = '<div class="poi-loading">No points of interest found in this area.</div>';
                return;
            }
            
            // Add heading
            poiContainer.innerHTML = `<h3>Points of Interest (${pois.length})</h3>`;
            
            // Create POI list
            const poiList = document.createElement('ul');
            poiList.className = 'poi-list';
            
            // Add POIs to list and map
            pois.forEach(poi => {
                // Create list item for sidebar
                const poiItem = document.createElement('li');
                poiItem.className = 'poi-item';
                poiItem.dataset.poiId = poi.id;
                
                poiItem.innerHTML = `
                    <div class="poi-name">${poi.name}</div>
                    <div class="poi-address">${poi.address}</div>
                    <div class="poi-rating">â ${poi.rating}</div>
                    <div class="poi-type">${poi.type.charAt(0).toUpperCase() + poi.type.slice(1)}</div>
                    <button class="poi-directions-btn">Get Directions</button>
                `;
                
                // Add event listener for clicking on the POI item
                poiItem.addEventListener('click', function() {
                    // Remove selected class from all POIs
                    document.querySelectorAll('.poi-item').forEach(item => {
                        item.classList.remove('selected');
                    });
                    
                    // Add selected class to clicked POI
                    this.classList.add('selected');
                    
                    // Center map on POI
                    map.setView([poi.lat, poi.lng], 17);
                    
                    // Open the popup for this POI
                    const marker = markers.find(m => m.poiId === poi.id);
                    if (marker) {
                        marker.openPopup();
                    }
                });
                
                // Add event listener for directions button
                poiItem.querySelector('.poi-directions-btn').addEventListener('click', function(e) {
                    e.stopPropagation(); // Prevent triggering the parent's click event
                    
                    // Set as destination
                    document.getElementById('destinationLocation').value = '';
                    placeMarker({ lat: poi.lat, lng: poi.lng }, 'destination');
                    
                    // Calculate route if source is already set
                    if (sourceMarker) {
                        handleFindPathClick();
                    } else {
                        alert('Please select a source location first');
                    }
                });
                
                // Add to list
                poiList.appendChild(poiItem);
                
                // Create marker for the map
                const marker = L.marker([poi.lat, poi.lng], {
                    icon: poiTypeIcons[poi.type] || markerIcons.poi
                }).addTo(map);
                
                // Add ID to marker for reference
                marker.poiId = poi.id;
                
                // Create popup for the marker
                const popupContent = document.createElement('div');
                popupContent.className = 'poi-info-window';
                popupContent.innerHTML = `
                    <h3>${poi.name}</h3>
                    <p>${poi.address}</p>
                    <p>Rating: â ${poi.rating}</p>
                    <p>Type: ${poi.type.charAt(0).toUpperCase() + poi.type.slice(1)}</p>
                    <button class="set-as-destination">Set as Destination</button>
                `;
                
                // Bind popup to marker
                marker.bindPopup(popupContent);
                
                // Add event listener for popup open
                marker.on('popupopen', function() {
                    // Add click handler for 'Set as Destination' button
                    document.querySelector('.set-as-destination').addEventListener('click', function() {
                        // Set as destination
                        document.getElementById('destinationLocation').value = '';
                        placeMarker({ lat: poi.lat, lng: poi.lng }, 'destination');
                        
                        // Calculate route if source is already set
                        if (sourceMarker) {
                            handleFindPathClick();
                        } else {
                            alert('Please select a source location first');
                        }
                        
                        // Close popup
                        marker.closePopup();
                    });
                });
                
                // Add marker to global array
                markers.push(marker);
            });
            
            // Add POI list to container
            poiContainer.appendChild(poiList);
        }

        // Reset the map
        function resetMap() {
            // Clear route
            routeLayer.clearLayers();
            
            // Remove markers
            markers.forEach(marker => {
                map.removeLayer(marker);
            });
            
            // Reset markers array
            markers = [];
            sourceMarker = null;
            destinationMarker = null;
            
            // Clear route info
            document.getElementById('routeInfo').innerHTML = '';
            
            // Clear POI container
            document.getElementById('poiContainer').innerHTML = '';
            
            // Reset dropdowns
            document.getElementById('sourceLocation').value = '';
            document.getElementById('destinationLocation').value = '';
            
            // Reset center and zoom
            map.setView(HALDWANI_CENTER, HALDWANI_ZOOM);
        }

        // Show all locations
        function showAllLocations() {
            // Clear previous markers (except source and destination)
            markers.forEach(marker => {
                if (marker !== sourceMarker && marker !== destinationMarker) {
                    map.removeLayer(marker);
                }
            });
            
            // Keep only source and destination markers
            markers = markers.filter(marker => marker === sourceMarker || marker === destinationMarker);
            
            // Add markers for all nodes
            haldwaniData.nodes.forEach(node => {
                // Create marker
                const marker = L.marker([node.lat, node.lng], {
                    icon: markerIcons.poi
                }).addTo(map);
                
                // Create popup
                const popupContent = document.createElement('div');
                popupContent.className = 'location-info-window';
                popupContent.innerHTML = `
                    <h3>${node.name}</h3>
                    <p>Latitude: ${node.lat.toFixed(6)}</p>
                    <p>Longitude: ${node.lng.toFixed(6)}</p>
                    <button class="set-as-source">Set as Source</button>
                    <button class="set-as-destination">Set as Destination</button>
                `;
                
                // Bind popup to marker
                marker.bindPopup(popupContent);
                
                // Add event listener for popup open
                marker.on('popupopen', function() {
                    // Add click handler for 'Set as Source' button
                    document.querySelector('.set-as-source').addEventListener('click', function() {
                        document.getElementById('sourceLocation').value = node.id;
                        updateSelectedLocation('source', node.id);
                        marker.closePopup();
                    });
                    
                    // Add click handler for 'Set as Destination' button
                    document.querySelector('.set-as-destination').addEventListener('click', function() {
                        document.getElementById('destinationLocation').value = node.id;
                        updateSelectedLocation('destination', node.id);
                        marker.closePopup();
                    });
                });
                
                // Add to markers array
                markers.push(marker);
            });
            
            // Create bounds to fit all markers
            const bounds = L.latLngBounds(haldwaniData.nodes.map(node => [node.lat, node.lng]));
            
            // Fit map to bounds
            map.fitBounds(bounds, {
                padding: [50, 50]
            });
        }
    </script>
</body>
</html>